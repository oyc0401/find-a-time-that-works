/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * FindTime API
 * Í≤πÏπòÎäî ÏãúÍ∞Ñ Ï∞æÍ∏∞ API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateRoomApiResponseDto,
  CreateRoomDto,
  DeleteRoomApiResponseDto,
  DeleteRoomDto,
  ExtendRoomApiResponseDto,
  RoomDetailApiResponseDto,
  SubmitAvailabilityApiResponseDto,
  SubmitAvailabilityDto,
  UpdateNicknameApiResponseDto,
  UpdateNicknameDto,
  UpdateRoomNameApiResponseDto,
  UpdateRoomNameDto
} from '.././models';

import { customFetch } from '../../client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Î∞© ÏÉùÏÑ±
 */
export type roomsControllerCreateResponse201 = {
  data: CreateRoomApiResponseDto
  status: 201
}
    
export type roomsControllerCreateResponseSuccess = (roomsControllerCreateResponse201) & {
  headers: Headers;
};
;

export type roomsControllerCreateResponse = (roomsControllerCreateResponseSuccess)

export const getRoomsControllerCreateUrl = () => {


  

  return `/rooms`
}

export const roomsControllerCreate = async (createRoomDto: CreateRoomDto, options?: RequestInit): Promise<roomsControllerCreateResponse> => {
  
  return customFetch<roomsControllerCreateResponse>(getRoomsControllerCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createRoomDto,)
  }
);}




export const getRoomsControllerCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof roomsControllerCreate>>, TError,{data: CreateRoomDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof roomsControllerCreate>>, TError,{data: CreateRoomDto}, TContext> => {

const mutationKey = ['roomsControllerCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof roomsControllerCreate>>, {data: CreateRoomDto}> = (props) => {
          const {data} = props ?? {};

          return  roomsControllerCreate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RoomsControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof roomsControllerCreate>>>
    export type RoomsControllerCreateMutationBody = CreateRoomDto
    export type RoomsControllerCreateMutationError = unknown

    /**
 * @summary Î∞© ÏÉùÏÑ±
 */
export const useRoomsControllerCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof roomsControllerCreate>>, TError,{data: CreateRoomDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof roomsControllerCreate>>,
        TError,
        {data: CreateRoomDto},
        TContext
      > => {
      return useMutation(getRoomsControllerCreateMutationOptions(options), queryClient);
    }
    /**
 * @summary Î∞© ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export type roomsControllerFindByIdResponse200 = {
  data: RoomDetailApiResponseDto
  status: 200
}

export type roomsControllerFindByIdResponse404 = {
  data: void
  status: 404
}

export type roomsControllerFindByIdResponse410 = {
  data: void
  status: 410
}
    
export type roomsControllerFindByIdResponseSuccess = (roomsControllerFindByIdResponse200) & {
  headers: Headers;
};
export type roomsControllerFindByIdResponseError = (roomsControllerFindByIdResponse404 | roomsControllerFindByIdResponse410) & {
  headers: Headers;
};

export type roomsControllerFindByIdResponse = (roomsControllerFindByIdResponseSuccess | roomsControllerFindByIdResponseError)

export const getRoomsControllerFindByIdUrl = (id: string,) => {


  

  return `/rooms/${id}`
}

export const roomsControllerFindById = async (id: string, options?: RequestInit): Promise<roomsControllerFindByIdResponse> => {
  
  return customFetch<roomsControllerFindByIdResponse>(getRoomsControllerFindByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getRoomsControllerFindByIdQueryKey = (id: string,) => {
    return [
    `/rooms/${id}`
    ] as const;
    }

    
export const getRoomsControllerFindByIdQueryOptions = <TData = Awaited<ReturnType<typeof roomsControllerFindById>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof roomsControllerFindById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRoomsControllerFindByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof roomsControllerFindById>>> = ({ signal }) => roomsControllerFindById(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof roomsControllerFindById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RoomsControllerFindByIdQueryResult = NonNullable<Awaited<ReturnType<typeof roomsControllerFindById>>>
export type RoomsControllerFindByIdQueryError = void


export function useRoomsControllerFindById<TData = Awaited<ReturnType<typeof roomsControllerFindById>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof roomsControllerFindById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof roomsControllerFindById>>,
          TError,
          Awaited<ReturnType<typeof roomsControllerFindById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRoomsControllerFindById<TData = Awaited<ReturnType<typeof roomsControllerFindById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof roomsControllerFindById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof roomsControllerFindById>>,
          TError,
          Awaited<ReturnType<typeof roomsControllerFindById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRoomsControllerFindById<TData = Awaited<ReturnType<typeof roomsControllerFindById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof roomsControllerFindById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î∞© ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useRoomsControllerFindById<TData = Awaited<ReturnType<typeof roomsControllerFindById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof roomsControllerFindById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRoomsControllerFindByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Î∞© ÏÇ≠Ï†ú
 */
export type roomsControllerDeleteRoomResponse200 = {
  data: DeleteRoomApiResponseDto
  status: 200
}

export type roomsControllerDeleteRoomResponse403 = {
  data: void
  status: 403
}

export type roomsControllerDeleteRoomResponse404 = {
  data: void
  status: 404
}
    
export type roomsControllerDeleteRoomResponseSuccess = (roomsControllerDeleteRoomResponse200) & {
  headers: Headers;
};
export type roomsControllerDeleteRoomResponseError = (roomsControllerDeleteRoomResponse403 | roomsControllerDeleteRoomResponse404) & {
  headers: Headers;
};

export type roomsControllerDeleteRoomResponse = (roomsControllerDeleteRoomResponseSuccess | roomsControllerDeleteRoomResponseError)

export const getRoomsControllerDeleteRoomUrl = (id: string,) => {


  

  return `/rooms/${id}`
}

export const roomsControllerDeleteRoom = async (id: string,
    deleteRoomDto: DeleteRoomDto, options?: RequestInit): Promise<roomsControllerDeleteRoomResponse> => {
  
  return customFetch<roomsControllerDeleteRoomResponse>(getRoomsControllerDeleteRoomUrl(id),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      deleteRoomDto,)
  }
);}




export const getRoomsControllerDeleteRoomMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof roomsControllerDeleteRoom>>, TError,{id: string;data: DeleteRoomDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof roomsControllerDeleteRoom>>, TError,{id: string;data: DeleteRoomDto}, TContext> => {

const mutationKey = ['roomsControllerDeleteRoom'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof roomsControllerDeleteRoom>>, {id: string;data: DeleteRoomDto}> = (props) => {
          const {id,data} = props ?? {};

          return  roomsControllerDeleteRoom(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RoomsControllerDeleteRoomMutationResult = NonNullable<Awaited<ReturnType<typeof roomsControllerDeleteRoom>>>
    export type RoomsControllerDeleteRoomMutationBody = DeleteRoomDto
    export type RoomsControllerDeleteRoomMutationError = void

    /**
 * @summary Î∞© ÏÇ≠Ï†ú
 */
export const useRoomsControllerDeleteRoom = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof roomsControllerDeleteRoom>>, TError,{id: string;data: DeleteRoomDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof roomsControllerDeleteRoom>>,
        TError,
        {id: string;data: DeleteRoomDto},
        TContext
      > => {
      return useMutation(getRoomsControllerDeleteRoomMutationOptions(options), queryClient);
    }
    /**
 * @summary Î∞© Ïù¥Î¶Ñ Î≥ÄÍ≤Ω
 */
export type roomsControllerUpdateRoomNameResponse200 = {
  data: UpdateRoomNameApiResponseDto
  status: 200
}

export type roomsControllerUpdateRoomNameResponse403 = {
  data: void
  status: 403
}

export type roomsControllerUpdateRoomNameResponse404 = {
  data: void
  status: 404
}
    
export type roomsControllerUpdateRoomNameResponseSuccess = (roomsControllerUpdateRoomNameResponse200) & {
  headers: Headers;
};
export type roomsControllerUpdateRoomNameResponseError = (roomsControllerUpdateRoomNameResponse403 | roomsControllerUpdateRoomNameResponse404) & {
  headers: Headers;
};

export type roomsControllerUpdateRoomNameResponse = (roomsControllerUpdateRoomNameResponseSuccess | roomsControllerUpdateRoomNameResponseError)

export const getRoomsControllerUpdateRoomNameUrl = (id: string,) => {


  

  return `/rooms/${id}`
}

export const roomsControllerUpdateRoomName = async (id: string,
    updateRoomNameDto: UpdateRoomNameDto, options?: RequestInit): Promise<roomsControllerUpdateRoomNameResponse> => {
  
  return customFetch<roomsControllerUpdateRoomNameResponse>(getRoomsControllerUpdateRoomNameUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateRoomNameDto,)
  }
);}




export const getRoomsControllerUpdateRoomNameMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof roomsControllerUpdateRoomName>>, TError,{id: string;data: UpdateRoomNameDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof roomsControllerUpdateRoomName>>, TError,{id: string;data: UpdateRoomNameDto}, TContext> => {

const mutationKey = ['roomsControllerUpdateRoomName'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof roomsControllerUpdateRoomName>>, {id: string;data: UpdateRoomNameDto}> = (props) => {
          const {id,data} = props ?? {};

          return  roomsControllerUpdateRoomName(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RoomsControllerUpdateRoomNameMutationResult = NonNullable<Awaited<ReturnType<typeof roomsControllerUpdateRoomName>>>
    export type RoomsControllerUpdateRoomNameMutationBody = UpdateRoomNameDto
    export type RoomsControllerUpdateRoomNameMutationError = void

    /**
 * @summary Î∞© Ïù¥Î¶Ñ Î≥ÄÍ≤Ω
 */
export const useRoomsControllerUpdateRoomName = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof roomsControllerUpdateRoomName>>, TError,{id: string;data: UpdateRoomNameDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof roomsControllerUpdateRoomName>>,
        TError,
        {id: string;data: UpdateRoomNameDto},
        TContext
      > => {
      return useMutation(getRoomsControllerUpdateRoomNameMutationOptions(options), queryClient);
    }
    /**
 * @summary Í∞ÄÏö© ÏãúÍ∞Ñ ÏûÖÎ†•
 */
export type roomsControllerSubmitAvailabilityResponse201 = {
  data: SubmitAvailabilityApiResponseDto
  status: 201
}

export type roomsControllerSubmitAvailabilityResponse404 = {
  data: void
  status: 404
}

export type roomsControllerSubmitAvailabilityResponse410 = {
  data: void
  status: 410
}
    
export type roomsControllerSubmitAvailabilityResponseSuccess = (roomsControllerSubmitAvailabilityResponse201) & {
  headers: Headers;
};
export type roomsControllerSubmitAvailabilityResponseError = (roomsControllerSubmitAvailabilityResponse404 | roomsControllerSubmitAvailabilityResponse410) & {
  headers: Headers;
};

export type roomsControllerSubmitAvailabilityResponse = (roomsControllerSubmitAvailabilityResponseSuccess | roomsControllerSubmitAvailabilityResponseError)

export const getRoomsControllerSubmitAvailabilityUrl = (id: string,) => {


  

  return `/rooms/${id}/availability`
}

export const roomsControllerSubmitAvailability = async (id: string,
    submitAvailabilityDto: SubmitAvailabilityDto, options?: RequestInit): Promise<roomsControllerSubmitAvailabilityResponse> => {
  
  return customFetch<roomsControllerSubmitAvailabilityResponse>(getRoomsControllerSubmitAvailabilityUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      submitAvailabilityDto,)
  }
);}




export const getRoomsControllerSubmitAvailabilityMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof roomsControllerSubmitAvailability>>, TError,{id: string;data: SubmitAvailabilityDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof roomsControllerSubmitAvailability>>, TError,{id: string;data: SubmitAvailabilityDto}, TContext> => {

const mutationKey = ['roomsControllerSubmitAvailability'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof roomsControllerSubmitAvailability>>, {id: string;data: SubmitAvailabilityDto}> = (props) => {
          const {id,data} = props ?? {};

          return  roomsControllerSubmitAvailability(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RoomsControllerSubmitAvailabilityMutationResult = NonNullable<Awaited<ReturnType<typeof roomsControllerSubmitAvailability>>>
    export type RoomsControllerSubmitAvailabilityMutationBody = SubmitAvailabilityDto
    export type RoomsControllerSubmitAvailabilityMutationError = void

    /**
 * @summary Í∞ÄÏö© ÏãúÍ∞Ñ ÏûÖÎ†•
 */
export const useRoomsControllerSubmitAvailability = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof roomsControllerSubmitAvailability>>, TError,{id: string;data: SubmitAvailabilityDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof roomsControllerSubmitAvailability>>,
        TError,
        {id: string;data: SubmitAvailabilityDto},
        TContext
      > => {
      return useMutation(getRoomsControllerSubmitAvailabilityMutationOptions(options), queryClient);
    }
    /**
 * @summary Î∞© ÎßåÎ£å Í∏∞Í∞Ñ 30Ïùº Ïó∞Ïû•
 */
export type roomsControllerExtendRoomResponse201 = {
  data: ExtendRoomApiResponseDto
  status: 201
}

export type roomsControllerExtendRoomResponse404 = {
  data: void
  status: 404
}
    
export type roomsControllerExtendRoomResponseSuccess = (roomsControllerExtendRoomResponse201) & {
  headers: Headers;
};
export type roomsControllerExtendRoomResponseError = (roomsControllerExtendRoomResponse404) & {
  headers: Headers;
};

export type roomsControllerExtendRoomResponse = (roomsControllerExtendRoomResponseSuccess | roomsControllerExtendRoomResponseError)

export const getRoomsControllerExtendRoomUrl = (id: string,) => {


  

  return `/rooms/${id}/extend`
}

export const roomsControllerExtendRoom = async (id: string, options?: RequestInit): Promise<roomsControllerExtendRoomResponse> => {
  
  return customFetch<roomsControllerExtendRoomResponse>(getRoomsControllerExtendRoomUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getRoomsControllerExtendRoomMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof roomsControllerExtendRoom>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof roomsControllerExtendRoom>>, TError,{id: string}, TContext> => {

const mutationKey = ['roomsControllerExtendRoom'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof roomsControllerExtendRoom>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  roomsControllerExtendRoom(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RoomsControllerExtendRoomMutationResult = NonNullable<Awaited<ReturnType<typeof roomsControllerExtendRoom>>>
    
    export type RoomsControllerExtendRoomMutationError = void

    /**
 * @summary Î∞© ÎßåÎ£å Í∏∞Í∞Ñ 30Ïùº Ïó∞Ïû•
 */
export const useRoomsControllerExtendRoom = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof roomsControllerExtendRoom>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof roomsControllerExtendRoom>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getRoomsControllerExtendRoomMutationOptions(options), queryClient);
    }
    /**
 * @summary Ïú†Ï†Ä ÎãâÎÑ§ÏûÑ Î≥ÄÍ≤Ω
 */
export type roomsControllerUpdateNicknameResponse200 = {
  data: UpdateNicknameApiResponseDto
  status: 200
}

export type roomsControllerUpdateNicknameResponse404 = {
  data: void
  status: 404
}
    
export type roomsControllerUpdateNicknameResponseSuccess = (roomsControllerUpdateNicknameResponse200) & {
  headers: Headers;
};
export type roomsControllerUpdateNicknameResponseError = (roomsControllerUpdateNicknameResponse404) & {
  headers: Headers;
};

export type roomsControllerUpdateNicknameResponse = (roomsControllerUpdateNicknameResponseSuccess | roomsControllerUpdateNicknameResponseError)

export const getRoomsControllerUpdateNicknameUrl = (id: string,) => {


  

  return `/rooms/${id}/nickname`
}

export const roomsControllerUpdateNickname = async (id: string,
    updateNicknameDto: UpdateNicknameDto, options?: RequestInit): Promise<roomsControllerUpdateNicknameResponse> => {
  
  return customFetch<roomsControllerUpdateNicknameResponse>(getRoomsControllerUpdateNicknameUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateNicknameDto,)
  }
);}




export const getRoomsControllerUpdateNicknameMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof roomsControllerUpdateNickname>>, TError,{id: string;data: UpdateNicknameDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof roomsControllerUpdateNickname>>, TError,{id: string;data: UpdateNicknameDto}, TContext> => {

const mutationKey = ['roomsControllerUpdateNickname'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof roomsControllerUpdateNickname>>, {id: string;data: UpdateNicknameDto}> = (props) => {
          const {id,data} = props ?? {};

          return  roomsControllerUpdateNickname(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RoomsControllerUpdateNicknameMutationResult = NonNullable<Awaited<ReturnType<typeof roomsControllerUpdateNickname>>>
    export type RoomsControllerUpdateNicknameMutationBody = UpdateNicknameDto
    export type RoomsControllerUpdateNicknameMutationError = void

    /**
 * @summary Ïú†Ï†Ä ÎãâÎÑ§ÏûÑ Î≥ÄÍ≤Ω
 */
export const useRoomsControllerUpdateNickname = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof roomsControllerUpdateNickname>>, TError,{id: string;data: UpdateNicknameDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof roomsControllerUpdateNickname>>,
        TError,
        {id: string;data: UpdateNicknameDto},
        TContext
      > => {
      return useMutation(getRoomsControllerUpdateNicknameMutationOptions(options), queryClient);
    }
    